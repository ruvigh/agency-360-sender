AWSTemplateFormatVersion: '2010-09-09'
Description: Agency360 - Sender Account with Lambda function that has access PUT access to the Analytics account's SQS and S3 to send the data. Eventbridge configred to run every day at 0100

Parameters:
  Region:
    Type: String
    Default: ap-southeast-1
    Description: AWS Region for the Lambda function
    
  AnalyticsAccount:
    Type: String
    Default: 'ANALYTICS_ACCOUNT_ID'
    Description: Analytics Account ID
    
  S3Bucket:
    Type: String
    Default: 'agency360-data-bucket'
    Description: S3 bucket for storing data

Resources:
  SQSMetricsLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: agency360-sqs-metrics-daily
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          REGION: !Ref Region
          SQS_QUEUE_ARN: !Sub 'arn:aws:sqs:${Region}:${AnalyticsAccount}:agency360-sqs'
          BUCKET: !Ref S3Bucket
      Code:
        ZipFile: |
          """ IMPORTS """
          import boto3
          import json
          import os
          import calendar

          from dataclasses import dataclass, field
          from typing import Dict, List, Optional, Union, Any
          from botocore.exceptions import ClientError
          from datetime import datetime, timedelta
          from datetime import datetime
          from calendar import monthrange


          """ GLOABAL VARIABLES """
          ARN_SQS     = os.environ.get("SQS_QUEUE_ARN")
          REGION      = os.environ.get('REGION')#"ap-southeast-1"
          BUCKET      = os.environ.get('BUCKET')#"ap-southeast-1"


          SUCCESS     = "ðŸŸ¢"  # Green dot
          FAIL        = "ðŸŸ¡"  # yellow dot
          ERROR       = "ðŸ”´"  # Warning sign


          """ HELPER CLASSES """

          """  1. AWS RESPONSE MANAGER """

          #a. AWS Resource Data - To ensure the data format is strictly governed
          @dataclass
          class AWSResourceData:
              """Data structure for AWS resource information"""
              account: Dict[str, Any] = field(default_factory=dict)
              config: Dict[str, Any] = field(default_factory=dict)
              services: List[Dict[str, Any]] = field(default_factory=list)
              costs: List[Dict[str, Any]] = field(default_factory=list)
              security: List[Dict[str, Any]] = field(default_factory=list)
              logs: Dict[str, Any] = field(default_factory=dict)

          #b. AWS Resource Interface - To ensure that the response is strictly configured
          class AWSResourceInterface:
              """Interface for managing AWS resource data"""
              def __init__(self):
                  self.data = AWSResourceData()
              
              def set_account_info(self, account_info: Dict[str, Any]) -> None:
                  """Set account information"""
                  self.data.account = account_info

              def set_config_info(self, config: Dict[str, Any]) -> None:
                  """Set config information"""
                  self.data.config = config
              
              def set_cost_info(self, cost: Dict[str, Any]) -> None:
                  """Set config information"""
                  self.data.costs = cost

              def set_log_info(self, logs: Dict[str, Any]) -> None:
                  """Set config information"""
                  self.data.logs = logs
              
              def add_service(self, service: Dict[str, Any]) -> None:
                  """Add a service to the services list"""
                  if(type(service) == list):
                      self.data.services.extend(service)
                  else:
                      self.data.services.append(service)
              
              def add_cost(self, cost: Dict[str, Any]) -> None:
                  """Add a cost entry to the costs list"""
                  if(type(cost) == list):
                      self.data.costs.extend(cost)
                  else:
                      self.data.costs.append(cost)
              
              def add_security_finding(self, finding: Dict[str, Any]) -> None:
                  """Add a security finding to the security list"""
                  if(type(finding) == list):
                      self.data.security.extend(finding)
                  else:
                      self.data.security.append(finding)

              
              def get_all_data(self) -> Dict[str, Any]:
                  """Get all data in the specified format"""
                  return {
                      "account": self.data.account,
                      "config": self.data.config,
                      "service": self.data.services,
                      "cost": self.data.costs,
                      "security": self.data.security,
                      "logs": self.data.logs,
                  }

          #c. Response Headers - To ensure that the Response Headers are accessible
          @dataclass
          class ResponseHeaders:
              """Interface for HTTP headers"""
              _headers: Dict[str, str]

              @property
              def date(self) -> str:
                  return self._headers.get('date', '')

              @property
              def content_type(self) -> str:
                  return self._headers.get('content-type', '')

              @property
              def content_length(self) -> str:
                  return self._headers.get('content-length', '')

              @property
              def request_id(self) -> str:
                  return self._headers.get('x-amzn-requestid', '')

              @property
              def trace_id(self) -> str:
                  return self._headers.get('x-amzn-trace-id', '')

              @property
              def apigw_id(self) -> str:
                  return self._headers.get('x-amz-apigw-id', '')

          #d. AWS Response - Class to strictly configure the Responses
          @dataclass
          class AWSResponse:
              """Interface for AWS API responses"""
              _raw_response: Dict[str, Any]

              @property
              def headers(self) -> ResponseHeaders:
                  return ResponseHeaders(self._raw_response.get('ResponseMetadata', {}).get('HTTPHeaders', {}))

              @property
              def request_id(self) -> str:
                  return self._raw_response.get('ResponseMetadata', {}).get('RequestId', '')

              @property
              def status(self) -> int:
                  return self._raw_response.get('ResponseMetadata', {}).get('HTTPStatusCode', 500)
              
              @property
              def retry_attempts(self) -> int:
                  return self._raw_response.get('ResponseMetadata', {}).get('RetryAttempts', 0)

              @property
              def data(self) -> Dict[str, Any]:
                  return {k: v for k, v in self._raw_response.items() if k != 'ResponseMetadata'}

          """ 2. RESOURCE MANAGER """
          class AWSResourceManager:
              def __init__(self, account_id, account=None, start_date=None, end_date=None, interval="DAILY", region="ap-southeast-1"):
                  self.data           = AWSResourceInterface()
                  self.account        = account
                  self.account_id     = account_id
                  self.start_date     = start_date
                  self.end_date       = end_date
                  self.interval       = interval
                  self.region         = region
                  self.days           = 1
                  self.log            = {
                                          'account'   : "Pass",
                                          'cost'      : "Pass",
                                          'service'   : "Pass",
                                          'security'  : "Pass",
                                          'message'   : []
                                        }

              def get_date(self):
                  if not self.end_date:
                      self.end_date = datetime.now()
              
                  if(self.interval == "YEARLY"):
                      self.start_date = self.end_date.replace(month=1, day=1)
                      self.end_date   = self.end_date.replace(month=12, day=31)
                      self.days       = 366 if calendar.isleap(self.end_date.year) else 365
                      #self.days       = 365

                  elif(self.interval  == "MONTHLY"):
                      self.start_date = self.end_date.replace(day=1)
                      last_day_num    = calendar.monthrange(self.end_date.year, self.end_date.month)[1]
                      self.end_date   = self.end_date.replace(day=last_day_num)
                      self.days       = last_day_num
                      #self.days = 30

                  elif(self.interval  == "WEEKLY"):
                      self.start_date = self.end_date - timedelta(days=self.end_date.weekday())
                      self.end_date   = self.start_date + timedelta(days=6)
                      self.days       = 7

                  else:
                      self.days = 1
                      self.start_date = self.end_date - timedelta(days=self.days)
                  
                      # Default to 1 days ago since that's the maximum for detailed data
                      
                  #self.start_date = self.start_date.strftime('%Y-%m-%d')
                  #self.end_date   = self.end_date.strftime('%Y-%m-%d')
                  

                  return True
              
              def set_log(self, def_type, status="Pass", value=None):
                  self.log[def_type] = status
                  
                  # Ensure message is a list
                  if not isinstance(self.log['message'], list):
                      self.log['message'] = []
                      
                  if value:
                      try:
                          self.log['message'].append(value)
                      except AttributeError as e:
                          print(f"Error: message must be a list. Current type: {type(self.log['message'])}")
                          # Reset message to list if it's not
                          self.log['message'] = [value]
                  
                  self.data.set_log_info(self.log)

              def get_account_details(self):
                  
                  #Get comprehensive account details using AWS Account client
                  try:
                      account_client  = boto3.client('account')
                      #org_client      = boto3.client('organizations')
                      
                      result          = {
                                          'account_id'        : None,     
                                          'account_name'      : None,
                                          'account_email'     : None,
                                          'account_status'    : None,
                                          'account_arn'       : None,
                                          'joined_method'     : None,
                                          'joined_timestamp'  : None,
                                          'contact_info'      : {},
                                          'alternate_contacts': {},
                                        }

                      #Get Basic Information
                      try:
                          #account_info                = account_client.get_account_information()
                          
                          result['account_id']        = self.account_id
                          result['account_name']      = None#account_info['AccountName'] #this can be updated when the Boto package in lambda is at 1.38 currently it is 1.35
                          result['account_email']     = None
                          result['account_status']    = "ACTIVE"
                          result['account_arn']       = None
                          result['joined_method']     = None
                          result['joined_timestamp']  = None#str(account_info['AccountCreatedDate']) #this can be updated when the Boto package in lambda is at 1.38 currently it is 1.35
                                                            
                      except Exception as e:
                          print(f"Error getting basic account info: {str(e)}")

                      #Get Contact Information
                      try:
                          contact_info                    = AWSResponse(account_client.get_contact_information())
                          result['contact_info'] = {
                                                              'address_line1'     : contact_info.data.get('ContactInformation', {}).get('AddressLine1'),
                                                              'address_line2'     : contact_info.data.get('ContactInformation', {}).get('AddressLine2'),
                                                              'address_line3'     : contact_info.data.get('ContactInformation', {}).get('AddressLine3'),
                                                              'city'              : contact_info.data.get('ContactInformation', {}).get('City'),
                                                              'country_code'      : contact_info.data.get('ContactInformation', {}).get('CountryCode'),
                                                              'postal_code'       : contact_info.data.get('ContactInformation', {}).get('PostalCode'),
                                                              'state_or_region'   : contact_info.data.get('ContactInformation', {}).get('StateOrRegion'),
                                                              'company_name'      : contact_info.data.get('ContactInformation', {}).get('CompanyName'),
                                                              'phone_number'      : contact_info.data.get('ContactInformation', {}).get('PhoneNumber'),
                                                              'website_url'       : contact_info.data.get('ContactInformation', {}).get('WebsiteUrl'),
                                                              'full_name'         : contact_info.data.get('ContactInformation', {}).get('FullName')
                                                            }
                      except Exception as e:
                          print(f"Error getting contact information: {str(e)}")

                      #Get alternate contacts
                      try:
                          for contact_type in ['BILLING', 'OPERATIONS', 'SECURITY']:
                              try:
                                  alternate_contact = AWSResponse(account_client.get_alternate_contact(AlternateContactType=contact_type))
                                  result['alternate_contacts'][contact_type.lower()] = {
                                      'name'  : alternate_contact.data.get('AlternateContact', {}).get('Name'),
                                      'title' : alternate_contact.data.get('AlternateContact', {}).get('Title'),
                                      'email' : alternate_contact.data.get('AlternateContact', {}).get('EmailAddress'),
                                      'phone' : alternate_contact.data.get('AlternateContact', {}).get('PhoneNumber')
                                  }
                              except account_client.exceptions.ResourceNotFoundException:
                                  result['alternate_contacts'][contact_type.lower()] = None
                      except Exception as e:
                          print(f"Error getting alternate contacts: {str(e)}")

                      self.data.set_account_info(result)
                      # Updating Log
                      self.set_log(def_type="account")
                      return result

                  except Exception as e:
                      #print(f"Error in get_account_details: {str(e)}")
                      # Updating Log
                      self.set_log(def_type="account", status="Fail",value={'account':str(e)})
                      
                      return None
              
              def get_services(self):      
                  if(self.get_date()):
                      start_date  = self.start_date.strftime('%Y-%m-%d')
                      end_date    = self.end_date.strftime('%Y-%m-%d')
              
                      #Initializing client for Cost Explorer
                      ce_client   = boto3.client('ce')

                      try:
                          #Get cost and usage data by setting the filters & dimensions
                          response = AWSResponse(ce_client.get_cost_and_usage(
                              TimePeriod  = {
                                              'Start' : start_date,
                                              'End'   : end_date
                                          },
                              Granularity = self.interval,  # Changed from MONTHLY to DAILY for more granular data
                              Metrics     = ['UnblendedCost', 'UsageQuantity'],
                              GroupBy     = [
                                              {'Type': 'DIMENSION', 'Key': 'SERVICE'},
                                              {'Type': 'DIMENSION', 'Key': 'USAGE_TYPE'}
                                          ],
                              Filter      = {
                                              'Dimensions': {
                                                              'Key'   : 'LINKED_ACCOUNT',
                                                              'Values': [self.account_id]
                                                          }
                                          }
                          ))

                          services_data = []
                          
                          for result in response.data.get('ResultsByTime', []):
                              time_period = result['TimePeriod']
                              
                              for group in result.get('Groups', []):
                                  service     = group['Keys'][0]
                                  usage_type  = group['Keys'][1]
                                  metrics     = group['Metrics']
                                  
                                  # Extract usage unit from usage type
                                  usage_unit = None
                                  if '-' in usage_type:
                                      usage_unit = usage_type.split('-')[-1]
                                  
                                  service_data    = {
                                                      'service'           : service,
                                                      'date_from'         : time_period['Start'],
                                                      'date_to'           : time_period['End'],
                                                      'cost'              : float(metrics['UnblendedCost']['Amount']),
                                                      'currency'          : metrics['UnblendedCost']['Unit'],
                                                      'utilization'       : float(metrics['UsageQuantity']['Amount']) if float(metrics['UsageQuantity']['Amount']) > 0 else None,
                                                      'utilization_unit'  : usage_unit,
                                                      'usage_type'        : usage_type
                                                  }
                                  services_data.append(service_data)

                          # Aggregate data by service
                          aggregated_data = {}
                          for item in services_data:
                              service = item['service']
                              if service not in aggregated_data:
                                  aggregated_data[service]=   {
                                                                  'service'           : service,
                                                                  'date_from'         : item['date_from'],
                                                                  'date_to'           : item['date_to'],
                                                                  'cost'              : item['cost'],
                                                                  'currency'          : item['currency'],
                                                                  'utilization'       : item['utilization'],
                                                                  'utilization_unit'  : item['utilization_unit'],
                                                                  'usage_types'       : [item['usage_type']]
                                                              }
                              else:
                                  aggregated_data[service]['cost'] += item['cost']

                                  if item['utilization']:
                                      if aggregated_data[service]['utilization']:
                                          aggregated_data[service]['utilization'] += item['utilization']
                                      else:
                                          aggregated_data[service]['utilization'] = item['utilization']

                                  if item['usage_type'] not in aggregated_data[service]['usage_types']:
                                      aggregated_data[service]['usage_types'].append(item['usage_type'])

                          # Convert to list and sort by cost
                          result_data = list(aggregated_data.values())
                          result_data.sort(key=lambda x: x['cost'], reverse=True)

                          self.data.add_service(result_data)
                          # Updating Log
                          self.set_log(def_type="service")

                          return result_data
                  
                      except Exception as e:
                          #print(f"Error fetching services data: {str(e)}")
                          # Updating Log
                          self.set_log(def_type="service", status="Fail",value={'services_data':str(e)})
                          return None
              
              def get_cost(self):
                  #Get cost analysis summary with forecast for specific account
                  if(self.get_date()):
                      try:
                          ce_client       = boto3.client('ce')
                          end_date        = self.end_date.strftime('%Y-%m-%d')
                          start_date      = self.start_date.strftime('%Y-%m-%d')
                          
                          forecast_data   = []
                          forecast_end    = (datetime.now() + timedelta(days=30)).strftime('%Y-%m-%d')  # 30 day forecast

                          
                          
                          # Account filter
                          account_filter  = {
                                              'Dimensions'    : {
                                                                  'Key'   : 'LINKED_ACCOUNT',
                                                                  'Values': [self.account_id]
                                                              }
                                          }

                          # Get current period costs with service breakdown
                          try:
                              current_costs = AWSResponse(ce_client.get_cost_and_usage(
                                                                                          TimePeriod  =   {
                                                                                                              'Start' : start_date,
                                                                                                              'End'   : end_date
                                                                                                          },
                                                                                          Granularity =   self.interval,
                                                                                          Metrics     =   ['UnblendedCost'],
                                                                                          GroupBy     =   [{
                                                                                                              'Type'  : 'DIMENSION', 
                                                                                                              'Key'   : 'SERVICE'
                                                                                                          }],
                                                                                          Filter      =   account_filter
                                                                                      )
                                                          )

                              # Get previous period costs
                              prev_start      = (self.start_date - timedelta(days=self.days)).strftime('%Y-%m-%d')
                              prev_end        = start_date
                              previous_costs  = AWSResponse(ce_client.get_cost_and_usage(
                                                                                          TimePeriod  =   {
                                                                                                              'Start' : prev_start,
                                                                                                              'End'   : prev_end
                                                                                                          },
                                                                                          Granularity =   self.interval,
                                                                                          Metrics     =   ['UnblendedCost'],
                                                                                          GroupBy     =   [{
                                                                                                              'Type'  : 'DIMENSION', 
                                                                                                              'Key'   : 'SERVICE'
                                                                                                          }],
                                                                                          Filter      =   account_filter
                                                                                      )
                                                          )
                              
                              # Calculate current period total
                              current_total   = sum(
                                                      float(group['Metrics']['UnblendedCost']['Amount'])
                                                      for result in current_costs.data['ResultsByTime']
                                                      for group in result['Groups']
                                                  )

                              # Calculate previous period total
                              previous_total  = sum(
                                                      float(group['Metrics']['UnblendedCost']['Amount'])
                                                      for result in previous_costs.data['ResultsByTime']
                                                      for group in result['Groups']
                                                  )

                              # Get top services by cost
                              top_services = []
                              if current_costs.data['ResultsByTime']:
                                  latest_period   = current_costs.data['ResultsByTime'][-1]
                                  sorted_services = sorted(
                                                              latest_period['Groups'],
                                                              key     = lambda x: float(x['Metrics']['UnblendedCost']['Amount']),
                                                              reverse = True
                                                          )
                                  top_services    =   [   
                                                          {
                                                              'service': service['Keys'][0],
                                                              'cost': float(service['Metrics']['UnblendedCost']['Amount'])
                                                          }
                                                          for service in sorted_services[:5]  # Top 5 services
                                                      ]

                              # Calculate cost difference and percentage
                              cost_difference             = current_total - previous_total
                              cost_difference_percentage  = ((current_total - previous_total) / previous_total * 100) if previous_total > 0 else 0


                              # Get forecast
                              try:
                                  forecast = AWSResponse(ce_client.get_cost_forecast(
                                                                                      TimePeriod  = {
                                                                                                      'Start' : end_date,
                                                                                                      'End'   : forecast_end
                                                                                                  },
                                                                                      Metric      ='UNBLENDED_COST',
                                                                                      Granularity = self.interval,
                                                                                      Filter      = account_filter
                                                                                  )
                                                      )
                                  # Process forecast data
                                  
                                  for point in forecast.data.get('ForecastResultsByTime', []):
                                      forecast_data.append({
                                                              'period'                            : {
                                                                                                      'start' : point['TimePeriod']['Start'],
                                                                                                      'end'   : point['TimePeriod']['End']
                                                                                                  },
                                                              'amount'                            : float(point['MeanValue']),
                                                              'prediction_interval_lower_bound'   : float(point.get('PredictionIntervalLowerBound', 0)),
                                                              'prediction_interval_upper_bound'   : float(point.get('PredictionIntervalUpperBound', 0))
                                                          })
                                  
                              except Exception as e:
                                  #print(f"Error Fetching Cost Forecast data: {str(e)}")
                                  self.set_log(def_type="cost", status="Fail",value={'forecast_cost':str(e)})
                                  forecast_data = []
                                  

                              

                              # Create summary
                              summary =   {
                                              'account_id'                    : self.account_id,
                                              'current_period_cost'           : current_total,
                                              'previous_period_cost'          : previous_total,
                                              'cost_difference'               : cost_difference,
                                              'cost_difference_percentage'    : cost_difference_percentage,
                                              'potential_monthly_savings'     : 0,
                                              'anomalies_detected'            : 0,
                                              'saving_opportunities_count'    : 0,
                                              'top_services'                  : top_services,
                                              'period'                        : {
                                                                                  'start'         : start_date,
                                                                                  'end'           : end_date,
                                                                                  'granularity'   : self.interval
                                                                              },
                                              'forecast'                      : forecast_data
                                          }
                              #print(json.dumps(summary, indent=4))
                              self.data.add_cost(summary)
                              
                              # Updating Log
                              self.set_log(def_type="cost")
                              return summary

                          except Exception as e:
                              print(f"Error getting costs: {str(e)}")
                              # Updating Log
                              self.set_log(def_type="cost", status="Fail", value={'getting_cost':str(e)})
                              return None

                      except Exception as e:
                          print(f"Error in cost analysis: {str(e)}")
                          self.set_log(def_type="cost", status="Fail",value={'cost_analysis':str(e)})
                          return None
              
              def get_security(self):
                  if(self.get_date()):
                      try:
                          #1. Initialize
                          securityhub = boto3.client('securityhub', region_name=REGION)
                      
                          #2. API To fetch Services Data from Security Hub
                          service_findings    = {}
                          next_token          = None
                          
                          while True:
                              filters = {
                                          'CreatedAt' :   [{
                                                              'Start'     : self.start_date.isoformat(),
                                                              'End'       : self.end_date.isoformat()
                                                          }],
                                          'AwsAccountId': [{
                                                              'Value'     : self.account_id,
                                                              'Comparison': 'EQUALS'
                                                          }]
                                        }
                              
                              params  = {
                                          'Filters'   : filters,
                                          'MaxResults': 100
                                        }
                              
                              if next_token:
                                  params['NextToken'] = next_token
                      
                              #3. Fetch Data
                              response    = securityhub.get_findings(**params)
                              resp        = AWSResponse(response)
                      
                              if(resp.status != 200):
                                  return None
                              
                              #4. Format Data
                              for finding in resp.data['Findings']:
                                  # Get the service name from the generator ID or product ARN
                                  generator_id    = finding.get('GeneratorId', '')
                                  #getting the affected product
                                  generator       = generator_id.split('/')[1].split('.')[0] if '/' in generator_id else 'Unknown'
                                  service         = generator_id.split('/')[0] if '/' in generator_id else 'Unknown'
                                  
                                  if service not in service_findings:
                                      service_findings[service] = {
                                                                      'service'           : service,
                                                                      'total_findings'    : 0,
                                                                      'severity_counts'   : {
                                                                                              'CRITICAL'      : 0,
                                                                                              'HIGH'          : 0,
                                                                                              'MEDIUM'        : 0,
                                                                                              'LOW'           : 0,
                                                                                              'INFORMATIONAL' : 0
                                                                                            },
                                                                      'open_findings'     : 0,
                                                                      'resolved_findings' : 0,
                                                                      'findings'          : []
                                                                  }
                      
                                  #5. Aggregate and Add data
                                  # Update Counts for Findings
                                  service_findings[service]['total_findings'] += 1
                                  severity = finding.get('Severity', {}).get('Label', 'UNKNOWN')
                      
                                  if severity in service_findings[service]['severity_counts']:
                                      service_findings[service]['severity_counts'][severity] += 1
                                  
                                  # Update Counts by Workflow
                                  workflow_status = finding.get('Workflow', {}).get('Status')
                                  if workflow_status == 'RESOLVED':
                                      service_findings[service]['resolved_findings'] += 1
                                  else:
                                      service_findings[service]['open_findings'] += 1
                      
                                  # Add finding details to the findings array
                                  finding_details = {
                                                      'finding_id'        : finding.get('Id'),
                                                      'service'           : finding.get('Id').split("/")[1].split('.')[0] if finding.get('Id') and '/' in finding.get('Id') else 'Unknown',
                                                      'title'             : finding.get('Title'),
                                                      'description'       : finding.get('Description'),
                                                      'severity'          : severity,
                                                      'status'            : workflow_status or 'OPEN',
                                                      'resource_type'     : finding.get('Resources', [{}])[0].get('Type'),
                                                      'resource_id'       : finding.get('Resources', [{}])[0].get('Id'),
                                                      'created_at'        : finding.get('CreatedAt'),
                                                      'updated_at'        : finding.get('UpdatedAt'),
                                                      'recommendation'    : finding.get('Remediation', {}).get('Recommendation', {}).get('Text'),
                                                      'compliance_status' : finding.get('Compliance', {}).get('Status'),
                                                      'region'            : finding.get('Region'),
                                                      'workflow_state'    : finding.get('Workflow', {}).get('Status', 'NEW'),
                                                      'record_state'      : finding.get('RecordState', 'ACTIVE'),
                                                      'product_name'      : finding.get('ProductName'),
                                                      'company_name'      : finding.get('CompanyName'),
                                                      'product_arn'       : finding.get('ProductArn'),
                                                      'generator_id'      : finding.get('GeneratorId'),
                                                      'generator'         : generator
                                                    }
                                  
                                  service_findings[service]['findings'].append(finding_details)
                      
                              # Check for next token and continue if there are more results
                              next_token = response.get('NextToken')
                              if not next_token:
                                  break
                      
                          #6. Convert to list and sort by total findings
                          result = list(service_findings.values())
                          result.sort(key=lambda x: x['total_findings'], reverse=True)
                          
                          #7. Set to AWS Interface
                          self.data.add_security_finding(result)

                          #8. Updating Log
                          self.set_log(def_type="security")

                          #for testing only comment for production
                          #print(json.dumps(result, indent=4))

                          return result
                      
                      except Exception as e:
                          print(f"Error fetching security findings: {str(e)}")
                          self.set_log(def_type="security", status="Fail",value={'security_findings':str(e)})
                          return None

          """ 3. SQS MANAGER """
          class SQSManager:
              def __init__(self, queue_arn: str):
                  """
                  Initialize SQS wrapper with queue ARN
                  Args:
                      queue_arn (str): The ARN of the queue
                  """
                  self.queue_arn = queue_arn
                  self.region = queue_arn.split(':')[3]
                  self.account_id = queue_arn.split(':')[4]
                  self.queue_name = queue_arn.split(':')[-1]
                  self.sqs = boto3.client('sqs', region_name=self.region)
                  self.queue_url = self._get_queue_url()

              def _get_queue_url(self) -> str:
                  """
                  Get queue URL from ARN
                  Returns:
                      str: Queue URL
                  """
                  try:
                      response = self.sqs.get_queue_url(
                          QueueName=self.queue_name,
                          QueueOwnerAWSAccountId=self.account_id
                      )
                      return response['QueueUrl']
                  except ClientError as e:
                      print(f"Error getting queue URL: {e}")
                      raise

              def _generate_deduplication_id(self, message: Union[str, Dict]) -> str:
                  """
                  Kept for compatibility, not used in standard queues
                  """
                  return ""

              def send_message(self, 
                              message: Union[str, Dict],
                              message_group_id: str = None,  # Kept for compatibility
                              message_deduplication_id: str = None,  # Kept for compatibility
                              message_attributes: Dict = None,
                              delay_seconds: int = 0) -> Optional[Dict]:
                  """
                  Send a message to the queue
                  Args:
                      message (Union[str, Dict]): Message content
                      message_attributes (Dict): Optional message attributes
                      delay_seconds (int): Delay delivery of message
                  Returns:
                      Optional[Dict]: Message send result
                  """
                  try:
                      if isinstance(message, dict):
                          message = json.dumps(message)

                      params = {
                          'QueueUrl': self.queue_url,
                          'MessageBody': message,
                          'DelaySeconds': delay_seconds
                      }

                      if message_attributes:
                          params['MessageAttributes'] = message_attributes

                      response = self.sqs.send_message(**params)
                      return response
                  except ClientError as e:
                      print(f"Error sending message: {e}")
                      return None

              def receive_messages(self,
                                  message_group_id: str = None,  # Kept for compatibility
                                  max_messages: int = 1,
                                  wait_time_seconds: int = 20,
                                  visibility_timeout: int = 30,
                                  message_attributes: List[str] = None) -> List[Dict]:
                  """
                  Receive messages from the queue
                  Args:
                      max_messages (int): Maximum number of messages to receive (1-10)
                      wait_time_seconds (int): Long polling wait time
                      visibility_timeout (int): Visibility timeout in seconds
                      message_attributes (List[str]): List of message attribute names to receive
                  Returns:
                      List[Dict]: List of received messages
                  """
                  try:
                      params = {
                          'QueueUrl': self.queue_url,
                          'MaxNumberOfMessages': min(max_messages, 10),
                          'WaitTimeSeconds': wait_time_seconds,
                          'VisibilityTimeout': visibility_timeout,
                          'AttributeNames': ['All']
                      }

                      if message_attributes:
                          params['MessageAttributeNames'] = message_attributes
                      else:
                          params['MessageAttributeNames'] = ['All']

                      response    = self.sqs.receive_message(**params)
                      
                      return response.get('Messages', [])
                  except ClientError as e:
                      print(f"Error receiving messages: {e}")
                      return []

              def send_message_batch(self, messages: List[Dict]) -> Dict[str, List]:
                  """
                  Send multiple messages in a batch
                  Args:
                      messages (List[Dict]): List of messages with required format
                          Each message must contain:
                          - body: message content
                          Optional:
                          - delay_seconds: delay in seconds
                          - message_attributes: message attributes
                  Returns:
                      Dict[str, List]: Successful and failed message IDs
                  """
                  try:
                      entries = []
                      for i, msg in enumerate(messages):
                          entry = {
                              'Id': str(i),
                              'MessageBody': (json.dumps(msg['body']) 
                                            if isinstance(msg['body'], dict) 
                                            else msg['body'])
                          }
                          
                          if 'delay_seconds' in msg:
                              entry['DelaySeconds'] = msg['delay_seconds']
                          if 'message_attributes' in msg:
                              entry['MessageAttributes'] = msg['message_attributes']
                          
                          entries.append(entry)

                      response = self.sqs.send_message_batch(
                          QueueUrl=self.queue_url,
                          Entries=entries
                      )

                      successful = [msg['Id'] for msg in response.get('Successful', [])]
                      failed = [msg['Id'] for msg in response.get('Failed', [])]

                      return {
                          'successful': successful,
                          'failed': failed
                      }
                  except ClientError as e:
                      print(f"Error sending message batch: {e}")
                      return {'successful': [], 'failed': [str(i) for i in range(len(messages))]}

              def delete_message(self, receipt_handle: str) -> bool:
                  """
                  Delete a specific message from the queue using its receipt handle
                  Args:
                      receipt_handle (str): Receipt handle of the message to delete
                  Returns:
                      bool: Success status
                  """
                  try:
                      self.sqs.delete_message(
                          QueueUrl=self.queue_url,
                          ReceiptHandle=receipt_handle
                      )
                      return True
                  except ClientError as e:
                      print(f"Error deleting message: {e}")
                      return False

              def purge_queue(self) -> bool:
                  """
                  Purge all messages from the queue
                  Note: Can only be called once every 60 seconds
                  Returns:
                      bool: Success status
                  """
                  try:
                      self.sqs.purge_queue(QueueUrl=self.queue_url)
                      print("Queue purged successfully")
                      return True
                  except ClientError as e:
                      if 'AWS.SimpleQueueService.PurgeQueueInProgress' in str(e):
                          print("Purge already in progress. Please wait 60 seconds before retrying.")
                      else:
                          print(f"Error purging queue: {e}")
                      return False

          """ 4. TEST AWS SERVICES """
          class TestAwsServices:
              def __init__(self, params=None):
                  # Get current date and 30 days ago for CE
                  self.end_date           = datetime.now()
                  self.start_date         = self.end_date - timedelta(days=30)
                  self.aws_services       = {
                                              'sts'                : {
                                                                      'name'      : 'STS',
                                                                      'client'    : boto3.client('sts'), 
                                                                      'action'    : 'get_caller_identity', 
                                                                      'params'    : params,
                                                                      'status'    : False,
                                                                  },
                                              'account'            : {    
                                                                      'name'      : 'Account',
                                                                      'client'    : boto3.client('account'), 
                                                                      'action'    : 'get_contact_information', 
                                                                      'params'    : params,
                                                                      'status'    : False
                                                                  },
                                              'ce'                 : { 
                                                                      'name'      : 'Cost Explorer',
                                                                      'client'    : boto3.client('ce'), 
                                                                      'action'    : 'get_cost_and_usage', 
                                                                      'params'    : {
                                                                                      "TimePeriod"    :   {
                                                                                                              "Start"     : self.start_date.strftime("%Y-%m-%d"),
                                                                                                              "End"       : self.end_date.strftime("%Y-%m-%d")
                                                                                                          },
                                                                                      "Granularity"   :   "MONTHLY",
                                                                                      "Metrics"       :   ["UnblendedCost"],
                                                                                      "Filter"        :   {
                                                                                                              "Dimensions":   {
                                                                                                                              "Key"   : "USAGE_TYPE",
                                                                                                                              "Values": ["*"]
                                                                                                                              }
                                                                                                          }
                                                                                    },
                                                                      'status'    : False
                                                                  },
                                              'securityhub'        : {
                                                                      'name'      : 'Security Hub',
                                                                      'client'    : boto3.client('securityhub', region_name=REGION), 
                                                                      'action'    : 'describe_hub', 
                                                                      'params'    : params,
                                                                      'status'    : False
                                                                  },
                                              'resiliencehub'      : {
                                                                      'name'      : 'Resilience Hub',
                                                                      'client'    : boto3.client('resiliencehub', region_name=REGION), 
                                                                      'action'    : 'list_apps', 
                                                                      'params'    : params,
                                                                      'status'    : False
                                                                  },
                                              'config'             : {
                                                                      'name'      : 'AWS Config',
                                                                      'client'    : boto3.client('config', region_name=REGION),
                                                                      'action'    : 'describe_configuration_recorders', 
                                                                      'params'    : params,
                                                                      'status'    : False
                                                                  },
                                              """ 'iam'                : {
                                                                      'name'      : 'IAM',
                                                                      'client'    : boto3.client('iam'), 
                                                                      'action'    : 'list_users', 
                                                                      'params'    : params,
                                                                      'status'    : False
                                                                  },
                                              'ec2'                : {
                                                                      'name'      : 'EC2',
                                                                      'client'    : boto3.client('ec2'), 
                                                                      'action'    : 'describe_regions', 
                                                                      'params'    : params,
                                                                      'status'    : False
                                                                  }, """
                                              'application-signals': {   
                                                                      'name'      : 'Application Signals',
                                                                      'client'    : boto3.client('application-signals', region_name=REGION), 
                                                                      'action'    : 'close', 
                                                                      'params'    : params,
                                                                      'status'    : False
                                                                  },
                                              'sqs'                : {
                                                                      'name'      : 'SQS',
                                                                      'client'    : boto3.client('sqs', region_name=REGION), 
                                                                      'action'    : 'list_queues', 
                                                                      'params'    : params,
                                                                      'status'    : False
                                                                  }
                              }

              def _run_test(self, service):
                  try:
                      if service['params']:
                          service['client'].__getattribute__(service['action'])(**service['params'])
                      else:
                          service['client'].__getattribute__(service['action'])()
                      service['status'] = True
                      print(f"{SUCCESS} Connected to {service['name']}")
                  except ClientError as e:
                      print(f"{FAIL} Not Connected to {service['name']}: {str(e)}")
                      service['status'] = False
                  except Exception as e:
                      print(f"{ERROR} Error testing {service['name']}: {str(e)}")
                      service['status'] = None

              def test_aws_clients(self):
                  print("Testing Connectivity to AWS Service Clients")
                  print("*"*43)

                  passed  = 0
                  failed  = 0
                  counter = 0
                  
                  for key, val in self.aws_services.items():
                      self._run_test(val)
                      
                      if val['status'] == True:
                          passed += 1
                      elif val['status'] == False:
                          failed += 1

                      counter += 1
                  
                  error = counter - (passed + failed)
                  print(f"\n\033[92m{passed} Connected\033[0m \n\033[93m{failed} Not Connected\033[0m \n\033[91m{error} Has Errors\033[0m\n")

                  if(failed > 0):
                      return False
                  else:
                      return True

          """ 5. METHODS FOR LAMBDA """
          def test_connection():
              check = TestAwsServices()
              return check.test_aws_clients()  

          def upload_to_s3(account, data, interval, end_date):
              end_date    = datetime.now() if not end_date else end_date
              s3          = boto3.client('s3')
              timestamp   = end_date.strftime("%H%M%S")
              filename    = f'data/{account}/{end_date.year}_{end_date.month}_{end_date.day}_{timestamp}_{interval}_.json'
              
              try:
                  # Convert data to JSON string
                  json_data = json.dumps(data, indent=4)
                  
                  # Upload to S3
                  s3.put_object(Bucket=BUCKET,Key=filename,Body=json_data)
                  
                  #print(f"\nâœ“ All daily data successfully written to s3://{BUCKET}/{filename}")

                  result = {
                      "path"          : f"s3://{BUCKET}/{filename}",
                      "date_added"    : str(end_date.date()),
                      "account"       : account
                  }
                  return result
              
              except Exception as e:
                  print(f"\nâœ— Error writing to S3: {str(e)}")
                  return None

          def get_data(interval="DAILY", start_date=None, end_date=None):
              sts_client      = boto3.client('sts')
              
              identity        = AWSResponse(sts_client.get_caller_identity())
              account         = identity.data['Account']
              sqs             = SQSManager(queue_arn=ARN_SQS)
              end_date        = end_date
              start_date      = None
              
              interval        = interval
              aws             = AWSResourceManager(account_id=account, interval=interval, start_date=start_date, end_date=end_date)

              #1. Fetch Account Data
              aws.get_account_details()
              #2. Fetch Services Data
              aws.get_services()
              #3. Fetch Cost Data
              aws.get_cost()
              #4. Fetch security Data
              aws.get_security()
              #5. Get All Data
              data        = aws.data.get_all_data() 
              result      = upload_to_s3(data=data, account=account, end_date=end_date, interval=interval)

              return result

          #Load Daily Data
          def load_current_data(interval="DAILY", end_date=None):
              
              sqs         = SQSManager(queue_arn=ARN_SQS)
              data        = get_data(interval=interval)
              if(data is None):
                  return None
              else:
                  send_result = sqs.send_message(message=data)
                  return send_result
              
          #Load current year's historical data
          def load_historical_data():
              sqs         = SQSManager(queue_arn=ARN_SQS)
              till_date   = datetime.now()
              start_date  = datetime(till_date.year, 1, 1)  # January 1st of current year
              interval    = "DAILY"
              
              print(f"Will process daily data from {start_date.strftime('%d-%m-%Y')} to {till_date.strftime('%d-%m-%Y')}")

              current     = start_date
              count       = 0
              while current <= till_date:
                  formatted_date = current.strftime('%d-%m-%Y')
                  #print(f"Processing data for: {formatted_date}")
                  try:
                    
                      last_day_of_month   = monthrange(current.year, current.month)[1]
                      is_last_day         = current.day == last_day_of_month
                      interval            = "MONTHLY" if(is_last_day) else "DAILY"

                      if(is_last_day):
                          data                = get_data(interval="DAILY", end_date=current)
                          send_result         = sqs.send_message(message=data)
                          print(f"{SUCCESS} DAILY : {formatted_date} Loaded - {send_result['MessageId']}")

                      data                = get_data(interval=interval, end_date=current)
                      send_result         = sqs.send_message(message=data)
                      
                      print(f"{SUCCESS} {interval} : {formatted_date} Loaded - {send_result['MessageId']}")
                  except Exception as e:
                      print(f"{ERROR} {interval} : {formatted_date} Not Loaded - {str(e)}")
                      continue
                  
                  finally:
                      # Move to next day
                      current += timedelta(days=1)
                      count += 1
              
              return {"from":start_date.strftime('%d-%m-%Y'), "to":till_date.strftime('%d-%m-%Y'), "loaded":count}

          def process_data_status(has_daily, has_monthly, has_history, daily_data, monthly_data, history_data):
            daily_status    = f"{ERROR} No Daily Data"
            monthly_status  = f"{ERROR} No Monthly Data"
            history_status  = f"{ERROR} No Historical Data"
            
            if(has_daily and daily_data is not None):
                daily_status    = f"{SUCCESS} Daily Data - {daily_data['MessageId']}"

            if(has_monthly and monthly_data is not None):
                monthly_status    = f"{SUCCESS} Monthly Data - {monthly_data['MessageId']}"

            if(has_history and history_data is not None and len(history_data) == 0):
                history_status  = f"{SUCCESS} {history_data['count']} Historical Data Loaded between {history_data['from']} - {history_data['to']}"
            
            return [daily_status, monthly_status, history_status]

          def lambda_handler(event=None, context=None):
            
            has_daily     = False
            has_monthly   = False
            has_history   = False
            daily_data    = None
            monthly_data  = None
            history_data  = None
            status        = []

            if(test_connection()):
                print("*"*15,"Connected","*"*15)
                if (event is not None and isinstance(event, dict) and "history" in event and event['history'] == True):
                    print("Loading Historical Data")
                    history_data = load_historical_data()
                    has_history = True
                    print(f"{SUCCESS if(has_history) else ERROR} History Data")
                else:
                    print("Loading Daily & Monthly Data")
                    daily_data = load_current_data(interval="DAILY")

                    if(daily_data and daily_data is not None and daily_data['ResponseMetadata']['HTTPStatusCode'] == 200):
                        has_daily = True
                        monthly_data = load_current_data(interval="MONTHLY")
                        
                        if(monthly_data and monthly_data is not None and monthly_data['ResponseMetadata']['HTTPStatusCode'] == 200):
                            has_monthly = True
                    
                    status = process_data_status(has_daily, has_monthly, has_history, daily_data, monthly_data, history_data)
                    print(status[0])
                    print(status[1])
                    print(status[2])

                print("*"*14,"Disconnected","*"*13)
                    
            return status

      Runtime: python3.10
      Timeout: 300
      MemorySize: 512
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: agency360-all-account-service-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: Agency360AllAccountServicePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: AllowS3ReadAccess
                Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                  - s3:PutObject
                Resource:
                  - !Sub arn:aws:s3:::${S3Bucket}
                  - !Sub arn:aws:s3:::${S3Bucket}/*
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:DescribeSecret
                  - secretsmanager:ListSecrets
                Resource: "*"
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:GetQueueAttributes
                  - sqs:GetQueueUrl
                  - sqs:ListQueues
                Resource: "*"
              - Effect: Allow
                Action:
                  - sts:GetCallerIdentity
                  - sts:GetSessionToken
                Resource: "*"
              - Effect: Allow
                Action:
                  - account:GetContactInformation
                  - account:GetAlternateContact
                  - account:GetAccountInformation
                  - account:GetPrimaryEmail
                  - account:GetRegionOptStatus
                  - account:ListRegions
                Resource: "*"
              - Effect: Allow
                Action:
                  - organizations:ListAccounts
                  - organizations:ListAWSServiceAccessForOrganization
                  - organizations:DescribeAccount
                Resource: "*"
              - Effect: Allow
                Action:
                  - resiliencehub:ListAppAssessments
                  - resiliencehub:ListAppAssessmentResourceDrifts
                  - resiliencehub:ListApps
                  - resiliencehub:ListMetrics
                Resource: "*"
              - Effect: Allow
                Action:
                  - ce:GetCostAndUsage
                  - ce:GetCostForecast
                  - ce:GetAnomalies
                  - ce:GetAnomalyMonitors
                  - ce:GetCostCategories
                  - ce:GetDimensionValues
                  - ce:GetPreferences
                Resource: "*"
              - Effect: Allow
                Action:
                  - securityhub:GetFindings
                  - securityhub:DescribeHub
                  - securityhub:GetEnabledStandards
                  - securityhub:ListConfigurationPolicies
                Resource: "*"
              - Effect: Allow
                Action: sqs:SendMessage
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"
              - Effect: Allow
                Action:
                  - trustedadvisor:ListOrganizationRecommendationResources
                  - trustedadvisor:DescribeAccountAccess
                  - trustedadvisor:DescribeAccount
                  - support:GetInteraction
                  - support:SearchForCases
                  - support:DescribeTrustedAdvisorCheckResult
                  - support:DescribeTrustedAdvisorChecks
                  - support:DescribeTrustedAdvisorCheckSummaries
                  - support:DescribeServices
                Resource: "*"
              - Effect: Allow
                Action:
                  - config:GetResourceConfigHistory
                  - config:SelectResourceConfig
                  - config:DescribeConfigurationRecorders
                  - config:DescribeConfigurationRecorderStatus
                Resource: "*"
              - Effect: Allow
                Action:
                  - health:DescribeEvents
                  - health:DescribeEventDetails
                  - health:DescribeAffectedEntities
                Resource: "*"

  LambdaScheduleRule:
    Type: 'AWS::Events::Rule'
    Properties:
      Description: Trigger Lambda function every morning at 01:00 AM
      ScheduleExpression: cron(0 1 * * ? *)
      State: ENABLED
      Targets:
      - Arn: !GetAtt SQSMetricsLambdaFunction.Arn
        Id: SQSMetricsLambdaTarget

  LambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: 
        Ref: SQSMetricsLambdaFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt LambdaScheduleRule.Arn

